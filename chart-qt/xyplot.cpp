#include "xyplot.h"
#include "plot.h"

#include <QFile>
#include <QOpenGLContext>
#include <QOpenGLExtraFunctions>
#include <QOpenGLFunctions>
#include <QQuickWindow>
#include <QSGFlatColorMaterial>
#include <QSGGeometry>
#include <QSGGeometryNode>
#include <QSGRenderNode>

#include "axis.h"
#include "dataset.h"
#include "errorbarspipeline.h" // This file was autogenerated
#include "renderutils.h"
#include "xyplotpipeline.h" // This file was autogenerated

namespace chart_qt {

class XYPlot::XYRenderer final : public PlotRenderer {
public:
    void init() {
        _pipeline.setTopology(Pipeline::Topology::LineStrip);
        _pipeline.create(this);

        _xBuffer    = createBuffer<XYPlotPipeline::Vx>(BufferBase::Type::Dynamic, BufferBase::UsageFlag::VertexBuffer, _dataCount);
        _yBuffer    = createBuffer<XYPlotPipeline::Vy>(BufferBase::Type::Dynamic, BufferBase::UsageFlag::VertexBuffer, _dataCount);
        _ubuf       = createBuffer<XYPlotPipeline::Ubo>(BufferBase::Type::Dynamic, BufferBase::UsageFlag::UniformBuffer);

        _bindingSet = _pipeline.createBindingSet(this, XYPlotPipeline::Bindings{
                                                               .ubuf = _ubuf });

        _pipeline.setVxInputBuffer(_xBuffer);
        _pipeline.setVyInputBuffer(_yBuffer);

        _errorBarsPipeline.setTopology(Pipeline::Topology::Lines);
        _errorBarsPipeline.create(this);

        _errorBarsBuffer     = createBuffer<ErrorBarsPipeline::Pos>(BufferBase::Type::Dynamic, BufferBase::UsageFlag::VertexBuffer, _dataCount * 2);
        _errorBarsBindingSet = _errorBarsPipeline.createBindingSet(this, { .ubuf = _ubuf });

        _errorBarsPipeline.setPosInputBuffer(_errorBarsBuffer);
    }

    void needsUpdate(DataSet *ds) {
        _dataset = ds;
    }

    void updateData() {
        const int  dataCount = _dataset->getDataCount();

        const auto xdata     = _dataset->getValues(0).data();
        const auto ydata     = _dataset->getValues(1).data();

        _xBuffer.update([=](auto *data) {
            memcpy(data, xdata, dataCount * sizeof(float));
        });
        _yBuffer.update([=](auto *data) {
            memcpy(data, ydata, dataCount * sizeof(float));
        });

        if (_dataset->hasErrors) {
            const auto yPosErrors = _dataset->getPositiveErrors(1).data();
            const auto yNegErrors = _dataset->getNegativeErrors(1).data();

            _errorBarsBuffer.update([=](auto *data) {
                for (int i = 0; i < dataCount; ++i) {
                    data[2 * i].pos     = QVector2D(xdata[i], ydata[i] - yPosErrors[i]);
                    data[2 * i + 1].pos = QVector2D(xdata[i], ydata[i] + yNegErrors[i]);
                }
            });
        }

        _dataset = nullptr;
    }

    void prepare() final {
        auto dataCount = _dataCount;
        if (_dataset) {
            dataCount = _dataset->getDataCount();
        }

        if (!_pipeline.isCreated()) {
            _dataCount = dataCount;
            init();
        } else if (_dataCount != dataCount) {
            _dataCount = dataCount;
            // TODO resize buffers
        }

        if (_dataset) {
            updateData();
        }
    }

    void render(const QMatrix4x4 &matrix) final {
        _ubuf.update([&](XYPlotPipeline::Ubo *data) {
            auto m = matrix * _matrix;
            memcpy(data->qt_Matrix.data(), m.data(), 64);
        });

        bindPipeline(_errorBarsPipeline);
        bindBindingSet(_errorBarsBindingSet);
        draw(_dataCount * 2);

        bindPipeline(_pipeline);
        bindBindingSet(_bindingSet);
        draw(_dataCount);
    }

    XYPlotPipeline                 _pipeline;
    size_t                         _dataCount = 0;
    Buffer<XYPlotPipeline::Vx>     _xBuffer;
    Buffer<XYPlotPipeline::Vy>     _yBuffer;
    Buffer<XYPlotPipeline::Ubo>    _ubuf;
    BindingSet                     _bindingSet;

    ErrorBarsPipeline              _errorBarsPipeline;
    Buffer<ErrorBarsPipeline::Pos> _errorBarsBuffer;
    BindingSet                     _errorBarsBindingSet;

    DataSet                       *_dataset = nullptr;
    QMatrix4x4                     _matrix;
};

XYPlot::XYPlot() {
}

PlotRenderer *XYPlot::renderer() {
    if (!_renderer) {
        _renderer           = new XYRenderer;
        _renderer->_dataset = dataSet();
    }
    return _renderer;
}

void XYPlot::update(QQuickWindow *window, const QRect &chartRect, double devicePixelRatio, bool paused) {
    QMatrix4x4 m;
    const auto xa     = xAxis();
    const auto ya     = yAxis();

    const bool xinv   = xa && xa->direction() == Axis::Direction::RightToLeft;
    const bool yinv   = ya && ya->direction() == Axis::Direction::BottomToTop;

    double     xscale = xa ? (xinv ? -chartRect.width() : chartRect.width()) / (xa->max() - xa->min()) : 1;
    double     yscale = ya ? (yinv ? -chartRect.height() : chartRect.height()) / (ya->max() - ya->min()) : 1;
    m.scale(xscale, yscale);

    double xtr = xa ? (xinv ? -xa->max() : -xa->min()) : 0;
    double ytr = ya ? (yinv ? -ya->max() : -ya->min()) : 0;
    m.translate(xtr, ytr);

    _renderer->_matrix = m;
    if (needsUpdate() && !paused) {
        resetNeedsUpdate();

        _renderer->_dataset = dataSet();
    }
}

} // namespace chart_qt
