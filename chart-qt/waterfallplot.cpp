#include "waterfallplot.h"
#include "plot.h"

#include <QFile>
#include <QQuickWindow>
#include <QSGRenderNode>

#include "axis.h"
#include "dataset.h"
#include "waterfallpipeline.h" // This file was autogenerated

namespace chart_qt {

static constexpr int          TexHeight = 500;

class WaterfallPlot::Renderer final : public PlotRenderer {
public:
    void init() {
        _pipeline.setTopology(Pipeline::Topology::TriangleStrip);
        _pipeline.create(this);

        _buffer     = createBuffer<WaterfallPipeline::Vertex>(BufferBase::Type::Dynamic, BufferBase::UsageFlag::VertexBuffer, 4);
        _ubuf       = createBuffer<WaterfallPipeline::Ubo>(BufferBase::Type::Dynamic, BufferBase::UsageFlag::UniformBuffer);
        _texture    = createTexture<TextureFormat::R32F>({ 10000, TexHeight });

        _bindingSet = _pipeline.createBindingSet(this, { .ubuf      = _ubuf,
                                                               .tex = _texture });

        _pipeline.setVertexInputBuffer(_buffer);
    }

    void needsUpdate(DataSet *ds) {
        _dataset = ds;
    }

    void updateData() {
        const int  dataCount = _dataset->getDataCount();
        const auto ydata     = _dataset->getValues(1).data();

        if (_lineData.size() < 10000) {
            _lineData.resize(10000);
        }

        for (int i = 0; i < 10000; ++i) {
            _lineData[i] = ydata[i * 10];
        }

        const auto xdata = _dataset->getValues(0).data();
        _dataWidth       = xdata[dataCount - 1];

        updateTexture(_texture, QRect(0, _lineOffset, 10000, 1), _lineData.data());
        if (++_lineOffset == TexHeight) {
            _lineOffset = 0;
        }

        float startU = _xaxis[0] / _dataWidth;
        float endU   = _xaxis[1] / _dataWidth;

        _buffer.update([=](auto *data) {
            static const QVector2D vertices[] = {
                { 0, 0 },
                { 0, 1 },
                { 1, 0 },
                { 1, 1 },
            };
            for (int i = 0; i < 4; ++i) {
                data[i].vertex = vertices[i];
            }

            data[0].uv_in = { startU, 0 };
            data[1].uv_in = { startU, 1 };
            data[2].uv_in = { endU, 0 };
            data[3].uv_in = { endU, 1 };
        });

        _dataset = nullptr;
    }

    void prepare() final {
        if (!_pipeline.isCreated()) {
            init();
        }
        if (_dataset) {
            updateData();
        }
    }

    void render(const QMatrix4x4 &matrix) final {
        QMatrix4x4 m = matrix;
        m.scale(rect().width(), rect().height());

        _ubuf.update([&](WaterfallPipeline::Ubo *data) {
            memcpy(data->qt_Matrix.data(), m.data(), 64);
            data->gradient   = _gradient;
            data->lineOffset = _lineOffset;
        });

        bindPipeline(_pipeline);
        bindBindingSet(_bindingSet);
        draw(4);
    }

    void setGradient(float start, float stop) {
        _gradient = { start, stop };
    }

    WaterfallPipeline                 _pipeline;
    Buffer<WaterfallPipeline::Vertex> _buffer;
    Buffer<WaterfallPipeline::Ubo>    _ubuf;
    Texture<TextureFormat::R32F>      _texture;
    BindingSet                        _bindingSet;

    DataSet                          *_dataset    = nullptr;
    QVector2D                         _gradient   = { 0, 1 };
    int                               _lineOffset = 0;
    float                             _xaxis[2]   = { 0, 1 };
    float                             _dataWidth  = 1;
    std::vector<float>                _lineData;
};

WaterfallPlot::WaterfallPlot() {
    _renderer = new Renderer;
}

PlotRenderer *WaterfallPlot::renderer() {
    return _renderer;
}

void WaterfallPlot::update(QQuickWindow *window, const QRect &chartRect, double devicePixelRatio, bool paused) {
    if (auto xa = xAxis()) {
        _renderer->_xaxis[0] = xa->min();
        _renderer->_xaxis[1] = xa->max();
    }
    _renderer->setGradient(_gradientStart, _gradientStop);
    if (needsUpdate() && !paused) {
        resetNeedsUpdate();

        _renderer->_dataset = dataSet();
    }
}

double WaterfallPlot::gradientStart() const {
    return _gradientStart;
}

void WaterfallPlot::setGradientStart(double g) {
    if (_gradientStart != g) {
        _gradientStart = g;
        emit gradientChanged();
    }
}

double WaterfallPlot::gradientStop() const {
    return _gradientStop;
}

void WaterfallPlot::setGradientStop(double g) {
    if (_gradientStop != g) {
        _gradientStop = g;
        emit gradientChanged();
    }
}

} // namespace chart_qt
